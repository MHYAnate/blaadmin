using this set of data set 

{success: true, message: 'Products retrieved successfully', data: Array(10), pagination: {…}}data: Array(10)0: {id: 46, name: 'Figma UI Test Product', description: 'Full description from UI', manufacturerId: 24, createdAt: '2025-07-14T10:08:45.251Z', …}1: {id: 45, name: 'Test with New Fields', description: 'Complete product description here', manufacturerId: 24, createdAt: '2025-07-14T09:56:17.345Z', …}2: {id: 44, name: 'Test Product from Postman', description: 'Full description of the test product Test Product from Postman', manufacturerId: 24, createdAt: '2025-07-14T09:36:31.659Z', …}3: businessOwnerId: nullcategory: createdAt: "2025-05-21T15:03:29.638Z"id: 2name: "Processed & Packaged Foods"updatedAt: "2025-05-21T15:03:29.638Z"[[Prototype]]: ObjectcategoryId: 2createdAt: "2025-07-14T08:32:56.616Z"criticalLevel: 5description: "product 2 active Description"id: 43isActive: truemanufacturer: contactPerson: "Jemeel"country: "Nigeria"createdAt: "2025-07-10T03:02:54.763Z"email: "adeolaamisu66@gmail.com"id: 24logo: "https://res.cloudinary.com/dsj9phqyk/image/upload/v1752166200/manufacturers/lnrnzy2axipucmatfhb5.png"name: "mohammed"phone: "09012902746"status: trueupdatedAt: "2025-07-11T05:02:14.482Z"[[Prototype]]: ObjectmanufacturerId: 24name: "product 2 active"options: Array(1)0: createdAt: "2025-07-15T06:56:55.784Z"id: 19image: ['https://res.cloudinary.com/dsj9phqyk/image/upload/v1752481630/products/ptdxnpngc1yzu9ovzr8f.jpg']inventory: 99lowStockThreshold: 5markupType: "PERCENTAGE"markupValue: 2.5moq: 1platformProductOptionId: nullprice: 123productId: 43sellingPrice: 123stockPrice: 120unit: "container"updatedAt: "2025-07-15T06:56:55.784Z"value: "large value 2"weight: 99[[Prototype]]: Objectlength: 1[[Prototype]]: Array(0)platformProductId: nullpriceRange: max: 123min: 123[[Prototype]]: ObjectstockAlert: falsestockSummary: lowStockOptions: 0optionsCount: 1outOfStockOptions: 0totalStock: 99[[Prototype]]: ObjecttargetLevel: 50type: "platform"updatedAt: "2025-07-15T06:56:58.895Z"[[Prototype]]: Object4: {id: 41, name: 'product1 active', description: 'product1 active Description', manufacturerId: 24, createdAt: '2025-07-14T08:22:02.178Z', …}5: {id: 15, name: 'Lagos Agro Pounded Yam Flour', description: 'Premium yam flour specifically crafted for smooth pounded yam.', manufacturerId: 6, createdAt: '2025-07-08T11:25:37.195Z', …}6: {id: 22, name: 'Abuja Essentials Peanut Butter', description: 'Smooth peanut butter produced in bulk for versatile usage.', manufacturerId: 7, createdAt: '2025-07-08T11:25:37.195Z', …}7: {id: 23, name: 'Lagos Agro Garri', description: 'Cassava granules ready to reconstitute for everyday meals.', manufacturerId: 6, createdAt: '2025-07-08T11:25:37.195Z', …}8: {id: 13, name: 'Adeola manufacturing product 1', description: 'Product for manufacturers', manufacturerId: 24, createdAt: '2025-07-08T11:25:37.195Z', …}9: {id: 24, name: 'Lagos Agro Canned Beans', description: 'High-quality beans in cans suitable for stews and sauces.', manufacturerId: 6, createdAt: '2025-07-08T11:25:37.195Z', …}length: 10[[Prototype]]: Array(0)message: "Products retrieved successfully"pagination: {currentPage: 1, pageSize: 10, totalItems: 29, totalPages: 3, hasNextPage: true, …}success: true[[Prototype]]: Object
index.tsx:60 [object Object]

while maintaining the flow of this forms update the form to populate the product data following this logic

the logic goes like this

on the form the part that populate the price on the backed should reflex on the front end form as retail price

on the form the part that populate the selling price on the backend should reflex on the front end bulk price 

on the form the part that populate the stockprice on the backend should reflex on the front end stock price 


the stock price should be put in manually by the user on the form to populate the back end stock price

the retail price should be put in manually by the user on the form to populate the back end price

the bulk price should be put in either manually by the user on the form to populate the back end selling price or it should be a calculated discount based on the markupType: "PERCENTAGE" and corresponding markupValue as it relate directly to the retail price which is the price field on the backend

after all this for the priceRange : populate the max: with the retail price  and the min : with the bulk price


here are the form that would recieve inplementations

"use client";

import AddProduct from "./components/product-details";
import AddPricing from "./components/pricing";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Form } from "@/components/ui/form";
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";
import { useRouter } from "next/navigation";
import { apiClient } from "@/app/(admin)/admin/manufacturers/apiClient";
import { routes } from "@/services/api-routes/index";
import { ErrorHandler } from "@/services/errorHandler";

// Product option type
export type ProductOption = {
  name: string;
  value: string;
  imageFiles?: File[];
  images?: string[];
  inventory: number;
  stockPrice: number;
  markupType: "PERCENTAGE" | "FIXED";
  markupValue: number;
  sellingPrice: number;
  weight: number;
  unit: string;
  moq: number;
};

export default function AddProductsPage() {
  const router = useRouter();
  const [activeTab, setActiveTab] = useState<"add-product" | "add-pricing">("add-product");
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Form schema with validation
  const formSchema = z.object({
    name: z.string().min(3, "Product name must be at least 3 characters"),
    description: z.string().min(10, "Description must be at least 10 characters"),
    categoryId: z.string().min(1, "Category is required"),
    manufacturerId: z.string().min(1, "Manufacturer is required"),
    options: z.array(
      z.object({
        name: z.string().min(1, "Option name is required"),
        value: z.string().min(1, "Option value is required"),
        inventory: z.number().min(0, "Inventory cannot be negative"),
        stockPrice: z.number().min(0.01, "Cost price must be at least 0.01"),
        markupType: z.enum(["PERCENTAGE", "FIXED"]),
        markupValue: z.number().min(0, "Markup value cannot be negative"),
        sellingPrice: z.number().min(0.01, "Selling price must be at least 0.01"),
        weight: z.number().min(0.1, "Weight must be at least 0.1kg"),
        unit: z.string().min(1, "Unit is required"),
        moq: z.number().min(1, "MOQ must be at least 1"),
        imageFiles: z.array(z.instanceof(File)).optional(),
      })
    ).min(1, "At least one product option is required"),
  });

  type FormSchemaType = z.infer<typeof formSchema>;

  const form = useForm<FormSchemaType>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: "",
      description: "",
      categoryId: "",
      manufacturerId: "",
      options: [{
        name: "",
        value: "",
        inventory: 0,
        stockPrice: 0,
        markupType: "PERCENTAGE",
        markupValue: 0,
        sellingPrice: 0,
        weight: 0,
        unit: "",
        moq: 1,
        imageFiles: [],
      }],
    },
  });

  // Upload images to backend
  const uploadImages = async (files: File[]): Promise<string[]> => {
    if (!files || files.length === 0) return [];
    
    try {
      const formData = new FormData();
      files.forEach(file => formData.append("images", file));
      formData.append("folder", "products");
      
      const response = await apiClient.post("/upload", formData, {
        headers: { "Content-Type": "multipart/form-data" },
      });

      return response.data.urls || [];
    } catch (error: any) {
      console.error("Image upload failed:", error);
      throw new Error(error.response?.data?.error || error.message || "Image upload failed");
    }
  };

  const createProduct = async (payload: any) => {
    try {
      setIsSubmitting(true);
      const response = await apiClient.post(routes.createProduct(), payload);
      return response;
    } catch (error) {
      throw error;
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleFinalSubmit = async (values: FormSchemaType) => {
    try {
      // Upload images for each option
      const optionsWithImages = await Promise.all(
        values.options.map(async (option) => {
          let images: string[] = [];
          if (option.imageFiles && option.imageFiles.length > 0) {
            images = await uploadImages(option.imageFiles);
          }
          return {
            ...option,
            images,
            imageFiles: undefined, // Remove client-only field
          };
        })
      );

      // Create payload
      const payload = {
        name: values.name,
        description: values.description,
        categoryId: parseInt(values.categoryId),
        manufacturerId: parseInt(values.manufacturerId),
        type: "platform",
        criticalLevel: 5,
        targetLevel: 50,
        stockAlert: false,
        options: optionsWithImages.map(option => ({
          value: option.value,
          price: option.sellingPrice,
          moq: option.moq,
          images: option.images,
          inventory: option.inventory,
          stockPrice: option.stockPrice,
          markupType: option.markupType,
          markupValue: option.markupValue,
          sellingPrice: option.sellingPrice,
          weight: option.weight,
          unit: option.unit,
          lowStockThreshold: 5
        })),
      };

      // Create product
      const response = await createProduct(payload);
      
      toast.success("Product created successfully!");
      router.push("/admin/products");
    } catch (error: any) {
      console.error("Product creation failed:", error);
      
      // Handle specific error cases
      if (error.message.includes("name")) {
        form.setError("name", { 
          type: "manual", 
          message: "A product with this name already exists" 
        });
        setActiveTab("add-product");
      } else if (error.message.includes("category")) {
        form.setError("categoryId", { 
          type: "manual", 
          message: "Invalid category selected" 
        });
        setActiveTab("add-product");
      } else if (error.message.includes("manufacturer")) {
        form.setError("manufacturerId", { 
          type: "manual", 
          message: "Invalid manufacturer selected" 
        });
        setActiveTab("add-product");
      } else {
        const errorMessage = ErrorHandler(error) || "Failed to create product";
        toast.error(errorMessage);
      }
    }
  };

  const onSubmit = async () => {
    try {
      // Validate current tab fields
      const fields = activeTab === "add-product" 
        ? ["name", "description", "categoryId", "manufacturerId"] 
        : ["options"];
      
      const isValid = await form.trigger(fields as any);
      if (!isValid) return;

      if (activeTab === "add-product") {
        setActiveTab("add-pricing");
      } else {
        await handleFinalSubmit(form.getValues());
      }
    } catch (error) {
      toast.error("Validation failed. Please check your inputs.");
    }
  };

  return (
    <section>
      <Form {...form}>
        <form onSubmit={(e) => e.preventDefault()} className="mb-8 mt-6">
          {activeTab === "add-pricing" ? (
            <AddPricing form={form} isSubmitting={isSubmitting} />
          ) : (
            <AddProduct form={form} />
          )}

          <div className="flex justify-end gap-5 mt-8">
            {activeTab === "add-pricing" && (
              <Button
                variant="outline"
                type="button"
                className="w-auto py-4 px-[3rem] font-bold text-base"
                size="xl"
                onClick={() => setActiveTab("add-product")}
                disabled={isSubmitting}
              >
                Back
              </Button>
            )}
            <Button
              type="button"
              variant="warning"
              className="w-auto px-[3rem] py-4 font-bold text-base"
              size="xl"
              onClick={onSubmit}
              disabled={isSubmitting}
            >
              {isSubmitting ? "Processing..." : 
                activeTab === "add-product" ? "Next" : "Create Product"}
            </Button>
          </div>
        </form>
      </Form>
    </section>
  );
}

"use client";

import { FormField, FormItem, FormLabel, FormControl, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import Header from "@/app/(admin)/components/header";
import { UseFormReturn } from "react-hook-form";
import { Plus, Trash, X } from "lucide-react";
import Image from "next/image";
import { useDropzone } from "react-dropzone";
import { Key, useCallback } from "react";

interface iProps {
  form: UseFormReturn<any>;
  isSubmitting: boolean;
}

const AddPricing: React.FC<iProps> = ({ form, isSubmitting }) => {
  const { control, getValues, setValue, formState } = form;
  const options = form.watch("options") || [];

  const addOption = () => {
    setValue("options", [
      ...options,
      {
        name: "",
        value: "",
        inventory: 0,
        stockPrice: 0,
        markupType: "PERCENTAGE",
        markupValue: 0,
        sellingPrice: 0,
        weight: 0,
        unit: "",
        moq: 1,
        imageFiles: [],
      },
    ]);
  };

  const removeOption = (index: number) => {
    if (options.length <= 1) return;
    const newOptions = [...options];
    newOptions.splice(index, 1);
    setValue("options", newOptions);
  };

  const calculateSellingPrice = (index: number) => {
    const option = options[index];
    if (!option) return;

    let sellingPrice = 0;
    if (option.markupType === "PERCENTAGE") {
      sellingPrice = option.stockPrice * (1 + option.markupValue / 100);
    } else {
      sellingPrice = option.stockPrice + option.markupValue;
    }

    setValue(`options.${index}.sellingPrice`, Number(sellingPrice.toFixed(2)));
  };

  const onDrop = useCallback((acceptedFiles: File[], index: number) => {
    const currentFiles = getValues(`options.${index}.imageFiles`) || [];
    const newFiles = [...currentFiles, ...acceptedFiles];
    setValue(`options.${index}.imageFiles`, newFiles, { shouldValidate: true });
  }, [getValues, setValue]);

  const removeImage = (index: number, imageIndex: number) => {
    const currentFiles = [...getValues(`options.${index}.imageFiles`)];
    currentFiles.splice(imageIndex, 1);
    setValue(`options.${index}.imageFiles`, currentFiles, { shouldValidate: true });
  };

  return (
    <div>
      <Header
        title="Pricing & Inventory"
        subtext="Configure product options and pricing"
      />

      {options.map((_:any, index:any) => (
        <div key={index} className="mb-8 p-4 border rounded-lg">
          <div className="flex justify-between items-center mb-4">
            <h3 className="font-medium">Option #{index + 1}</h3>
            {options.length > 1 && (
              <Button
                type="button"
                variant="destructive"
                size="sm"
                onClick={() => removeOption(index)}
                disabled={isSubmitting}
              >
                <Trash size={16} />
              </Button>
            )}
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <FormField
              control={control}
              name={`options.${index}.name`}
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>Option Name</FormLabel>
                  <FormControl>
                    <Input placeholder="e.g., Size, Color" {...field} disabled={isSubmitting} />
                  </FormControl>
                  {fieldState.error && (
                    <FormMessage>{fieldState.error.message}</FormMessage>
                  )}
                </FormItem>
              )}
            />
            <FormField
              control={control}
              name={`options.${index}.value`}
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>Option Value</FormLabel>
                  <FormControl>
                    <Input placeholder="e.g., Large, 50KG" {...field} disabled={isSubmitting} />
                  </FormControl>
                  {fieldState.error && (
                    <FormMessage>{fieldState.error.message}</FormMessage>
                  )}
                </FormItem>
              )}
            />
          </div>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
            <FormField
              control={control}
              name={`options.${index}.unit`}
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>Unit</FormLabel>
                  <FormControl>
                    <Input placeholder="e.g., Bag, Kg" {...field} disabled={isSubmitting} />
                  </FormControl>
                  {fieldState.error && (
                    <FormMessage>{fieldState.error.message}</FormMessage>
                  )}
                </FormItem>
              )}
            />
            <FormField
              control={control}
              name={`options.${index}.weight`}
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>Weight (kg)</FormLabel>
                  <FormControl>
                    <Input
                      type="number"
                      min="0.1"
                      step="0.1"
                      value={field.value}
                      onChange={(e) => {
                        const val = parseFloat(e.target.value) || 0;
                        field.onChange(val);
                      }}
                      disabled={isSubmitting}
                    />
                  </FormControl>
                  {fieldState.error && (
                    <FormMessage>{fieldState.error.message}</FormMessage>
                  )}
                </FormItem>
              )}
            />
            <FormField
              control={control}
              name={`options.${index}.moq`}
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>MOQ (Minimum Order)</FormLabel>
                  <FormControl>
                    <Input
                      type="number"
                      min="1"
                      value={field.value}
                      onChange={(e) => {
                        const val = parseInt(e.target.value) || 1;
                        field.onChange(val);
                      }}
                      disabled={isSubmitting}
                    />
                  </FormControl>
                  {fieldState.error && (
                    <FormMessage>{fieldState.error.message}</FormMessage>
                  )}
                </FormItem>
              )}
            />
          </div>

          <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
            <FormField
              control={control}
              name={`options.${index}.stockPrice`}
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>Cost Price (₦)</FormLabel>
                  <FormControl>
                    <Input
                      type="number"
                      min="0"
                      step="0.01"
                      value={field.value}
                      onChange={(e) => {
                        const value = parseFloat(e.target.value) || 0;
                        field.onChange(value);
                        calculateSellingPrice(index);
                      }}
                      disabled={isSubmitting}
                    />
                  </FormControl>
                  {fieldState.error && (
                    <FormMessage>{fieldState.error.message}</FormMessage>
                  )}
                </FormItem>
              )}
            />
            <FormField
              control={control}
              name={`options.${index}.markupType`}
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>Markup Type</FormLabel>
                  <FormControl>
                    <select
                      className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
                      value={field.value}
                      onChange={(e) => {
                        field.onChange(e.target.value);
                        calculateSellingPrice(index);
                      }}
                      disabled={isSubmitting}
                    >
                      <option value="PERCENTAGE">Percentage</option>
                      <option value="FIXED">Fixed Amount</option>
                    </select>
                  </FormControl>
                  {fieldState.error && (
                    <FormMessage>{fieldState.error.message}</FormMessage>
                  )}
                </FormItem>
              )}
            />
            <FormField
              control={control}
              name={`options.${index}.markupValue`}
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>
                    {getValues(`options.${index}.markupType`) === "PERCENTAGE"
                      ? "Markup %"
                      : "Markup Amount (₦)"}
                  </FormLabel>
                  <FormControl>
                    <Input
                      type="number"
                      min="0"
                      step="0.01"
                      value={field.value}
                      onChange={(e) => {
                        const value = parseFloat(e.target.value) || 0;
                        field.onChange(value);
                        calculateSellingPrice(index);
                      }}
                      disabled={isSubmitting}
                    />
                  </FormControl>
                  {fieldState.error && (
                    <FormMessage>{fieldState.error.message}</FormMessage>
                  )}
                </FormItem>
              )}
            />
            <FormField
              control={control}
              name={`options.${index}.sellingPrice`}
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>Selling Price (₦)</FormLabel>
                  <FormControl>
                    <Input
                      type="number"
                      min="0.01"
                      step="0.01"
                      value={field.value}
                      readOnly
                      disabled={isSubmitting}
                    />
                  </FormControl>
                  {fieldState.error && (
                    <FormMessage>{fieldState.error.message}</FormMessage>
                  )}
                </FormItem>
              )}
            />
          </div>

          <FormField
            control={control}
            name={`options.${index}.inventory`}
            render={({ field, fieldState }) => (
              <FormItem className="w-full md:w-1/2 mb-6">
                <FormLabel>Inventory Quantity</FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    min="0"
                    value={field.value}
                    onChange={(e) => {
                      field.onChange(parseInt(e.target.value) || 0);
                    }}
                    disabled={isSubmitting}
                  />
                </FormControl>
                {fieldState.error && (
                  <FormMessage>{fieldState.error.message}</FormMessage>
                )}
              </FormItem>
            )}
          />

          {/* Image Upload Section */}
          <FormField
            control={control}
            name={`options.${index}.imageFiles`}
            render={({ field, fieldState }) => (
              <FormItem>
                <FormLabel>Product Images</FormLabel>
                <div className="flex flex-wrap gap-4 mb-4">
                  {field.value?.map((file: Blob | MediaSource, imgIndex: Key | null | undefined) => (
                    <div key={imgIndex} className="relative group">
                      <div className="relative w-24 h-24 rounded-md overflow-hidden border">
                        <Image
                          src={URL.createObjectURL(file)}
                          alt={`Option image`}
                          fill
                          className="object-cover"
                        />
                        <Button
                          type="button"
                          variant="destructive"
                          size="icon"
                          className="absolute top-1 right-1 h-6 w-6 rounded-full opacity-0 group-hover:opacity-100 transition-opacity"
                          onClick={() => removeImage(index, imgIndex as any)}
                          disabled={isSubmitting}
                        >
                          <X size={14} />
                        </Button>
                      </div>
                    </div>
                  ))}
                </div>
                
                <Dropzone 
                  onDrop={(files: File[]) => onDrop(files, index)} 
                  maxFiles={5 - (field.value?.length || 0)}
                  disabled={field.value?.length >= 5 || isSubmitting}
                />
                {fieldState.error && (
                  <FormMessage>{fieldState.error.message}</FormMessage>
                )}
              </FormItem>
            )}
          />
        </div>
      ))}

      <Button
        type="button"
        variant="outline"
        className="mt-4"
        onClick={addOption}
        disabled={isSubmitting}
      >
        <Plus size={16} className="mr-2" />
        Add Product Option
      </Button>
    </div>
  );
};

// Dropzone component
const Dropzone = ({ onDrop, maxFiles, disabled }: any) => {
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    maxFiles,
    maxSize: 5 * 1024 * 1024, // 5MB
    accept: { 'image/*': ['.png', '.jpg', '.jpeg'] },
    disabled,
  });

  return (
    <div
      {...getRootProps()}
      className={`border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors ${
        disabled 
          ? 'bg-gray-100 cursor-not-allowed' 
          : isDragActive 
            ? 'border-primary bg-primary/10' 
            : 'border-gray-300 hover:border-primary/70'
      }`}
    >
      <input {...getInputProps()} />
      <p className="text-gray-600">
        {isDragActive
          ? "Drop images here"
          : disabled
            ? "Maximum 5 images reached"
            : "Drag & drop images here, or click to select"}
      </p>
      <p className="text-sm text-gray-500 mt-2">
        PNG, JPG up to 5MB (max {maxFiles} files)
      </p>
    </div>
  );
};

export default AddPricing;



"use client";

import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm, useFieldArray } from "react-hook-form";
import { z } from "zod";
import { useEffect, useState, useCallback } from "react";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { toast } from "sonner";
import { apiClient } from "@/app/(admin)/admin/manufacturers/apiClient"; // Use the working apiClient
import { Trash, UploadCloud, Copy } from "lucide-react";
import Image from "next/image";
import { useDropzone } from "react-dropzone";

// Enhanced schema with all product option fields
const productSchema = z.object({
  name: z.string().min(3, "Name must be at least 3 characters"),
  description: z.string().optional(),
  categoryId: z.string().min(1, "Category is required"),
  manufacturerId: z.string().min(1, "Manufacturer is required"),
  isActive: z.boolean().optional(),
  type: z.string().min(1, "Type is required"),
  stockAlert: z.boolean().optional(),
  criticalLevel: z.coerce.number().min(0).optional(),
  targetLevel: z.coerce.number().min(0).optional(),
  options: z.array(z.object({
    id: z.number().optional(), // For existing options
    value: z.string().min(1, "Option value is required"),
    price: z.coerce.number().min(0, "Price must be 0 or more"),
    inventory: z.coerce.number().min(0, "Inventory must be 0 or more"),
    stockPrice: z.coerce.number().min(0, "Cost price must be 0 or more"),
    markupType: z.enum(["PERCENTAGE", "FIXED"]),
    markupValue: z.coerce.number().min(0, "Markup must be 0 or more"),
    sellingPrice: z.coerce.number().min(0, "Selling price must be 0 or more"),
    weight: z.coerce.number().min(0, "Weight must be 0 or more"),
    unit: z.string().min(1, "Unit is required"),
    moq: z.coerce.number().min(1, "MOQ must be at least 1"),
    lowStockThreshold: z.coerce.number().min(0).optional(),
    image: z.array(z.string()).optional(), // Existing images
    newImages: z.array(z.instanceof(File)).optional(), // New image files
  })).min(1, "At least one product option is required"),
});

type ProductFormValues = z.infer<typeof productSchema>;

// Helper function to process options (from working form)
const processOptions = (options: any[]) => {
  return options.map(option => ({
    value: option.value,
    price: parseFloat(option.price) || 0,
    moq: parseInt(option.moq) || 1,
    image: option.image || [],
    unit: option.unit || "",
    inventory: parseInt(option.inventory) || 0,
    lowStockThreshold: parseInt(option.lowStockThreshold) || 10,
    markupType: option.markupType || "FIXED",
    markupValue: parseFloat(option.markupValue) || 0,
    sellingPrice: parseFloat(option.sellingPrice) || 0,
    stockPrice: parseFloat(option.stockPrice) || 0,
    weight: parseFloat(option.weight) || 0,
  }));
};

interface Manufacturer {
  id: number;
  name: string;
}

interface Category {
  id: number;
  name: string;
}

interface IProps {
  product: any;
  manufacturers: Manufacturer[];
  categories?: Category[];
  setClose: () => void;
}

const EditProductForm: React.FC<IProps> = ({ 
  product, 
  manufacturers, 
  categories = [],
  setClose 
}) => {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [copiedOption, setCopiedOption] = useState<any>(null);

  const form = useForm<ProductFormValues>({
    resolver: zodResolver(productSchema),
    defaultValues: {
      name: "",
      description: "",
      categoryId: "",
      manufacturerId: "",
      isActive: false,
      type: "platform",
      stockAlert: false,
      criticalLevel: 5,
      targetLevel: 50,
      options: [],
    }
  });

  const { fields, append, remove } = useFieldArray({
    control: form.control,
    name: "options",
  });

  // Initialize form with product data
  useEffect(() => {
    if (product) {
      form.reset({
        name: product.name,
        description: product.description || "",
        categoryId: String(product.categoryId),
        manufacturerId: String(product.manufacturerId),
        isActive: product.isActive || false,
        type: product.type || "platform",
        stockAlert: product.stockAlert || false,
        criticalLevel: product.criticalLevel || 5,
        targetLevel: product.targetLevel || 50,
        options: product.options?.map((opt: any) => ({
          id: opt.id,
          value: opt.value,
          price: opt.price || 0,
          inventory: opt.inventory || 0,
          stockPrice: opt.stockPrice || 0,
          markupType: opt.markupType || "PERCENTAGE",
          markupValue: opt.markupValue || 0,
          sellingPrice: opt.sellingPrice || 0,
          weight: opt.weight || 0,
          unit: opt.unit || "",
          moq: opt.moq || 1,
          lowStockThreshold: opt.lowStockThreshold || 10,
          image: opt.image || [],
          newImages: [],
        })) || [],
      });
    }
  }, [product, form]);

  // Handle image uploads
  const uploadImages = async (files: File[]): Promise<string[]> => {
    if (!files || files.length === 0) return [];
    
    const formData = new FormData();
    files.forEach(file => formData.append("images", file));
    formData.append("folder", "products");
    
    try {
      setIsUploading(true);
      const response = await apiClient.post("/upload", formData, {
        headers: { "Content-Type": "multipart/form-data" },
      });
      return response.data.urls || [];
    } catch (error) {
      toast.error("Image upload failed. Please try again.");
      throw error;
    } finally {
      setIsUploading(false);
    }
  };

  // Calculate selling price when cost or markup changes
  const calculateSellingPrice = useCallback((index: number) => {
    const stockPrice = form.getValues(`options.${index}.stockPrice`);
    const markupType = form.getValues(`options.${index}.markupType`);
    const markupValue = form.getValues(`options.${index}.markupValue`);
    
    if (stockPrice >= 0 && markupValue >= 0) {
      let newSellingPrice = 0;
      if (markupType === "PERCENTAGE") {
        newSellingPrice = stockPrice * (1 + markupValue / 100);
      } else {
        newSellingPrice = stockPrice + markupValue;
      }
      form.setValue(`options.${index}.sellingPrice`, parseFloat(newSellingPrice.toFixed(2)));
      form.setValue(`options.${index}.price`, parseFloat(newSellingPrice.toFixed(2)));
    }
  }, [form]);

  // Copy/paste functionality
  const handleCopyOption = (index: number) => {
    const optionToCopy = form.getValues(`options.${index}`);
    const { id, ...optionData } = optionToCopy;
    setCopiedOption(optionData);
    toast.success("Option copied!");
  };

  const handlePasteOption = () => {
    if (copiedOption) {
      append({
        ...copiedOption,
        newImages: [],
      });
      toast.info("Option pasted!");
    } else {
      toast.warning("No option copied yet.");
    }
  };

  // Submit handler - using the working form's approach
  const onSubmit = async (values: ProductFormValues) => {
    setIsSubmitting(true);
    
    try {
      // Process options with image uploads
      const processedOptions = await Promise.all(
        values.options.map(async (option) => {
          let uploadedImageUrls: string[] = [];
          
          // Upload new images if any
          if (option.newImages && option.newImages.length > 0) {
            uploadedImageUrls = await uploadImages(option.newImages);
          }
          
          // Combine existing and new images
          const allImages = [...(option.image || []), ...uploadedImageUrls];
          
          return {
            ...option,
            image: allImages,
            newImages: undefined, // Remove client-only field
          };
        })
      );

      // Prepare update data - only include provided fields (from working form)
      const updateData = {
        ...(values.name !== undefined && { name: values.name }),
        ...(values.description !== undefined && { description: values.description }),
        ...(values.type !== undefined && { type: values.type }),
        ...(values.isActive !== undefined && { isActive: values.isActive }),
        ...(values.stockAlert !== undefined && { stockAlert: values.stockAlert }),
        ...(values.criticalLevel !== undefined && { criticalLevel: values.criticalLevel }),
        ...(values.targetLevel !== undefined && { targetLevel: values.targetLevel }),
        ...(values.categoryId !== undefined && { categoryId: parseInt(values.categoryId) }),
        ...(values.manufacturerId !== undefined && { manufacturerId: parseInt(values.manufacturerId) }),
        options: processOptions(processedOptions)
      };

      // Update product using the working API call pattern
      const response = await apiClient.patch(`/admin/products/${product.id}`, updateData);
      
      if (response.data.success) {
        toast.success("Product updated successfully!");
        setClose();
      } else {
        throw new Error(response.data.error || "Failed to update product");
      }
    } catch (error: any) {
      console.error("Update failed:", error);
      toast.error(error.message || "Failed to update product");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="space-y-6">
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
          {/* Product Details */}
          <div className="p-4 border rounded-lg">
            <h3 className="text-lg font-medium mb-4">Product Details</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <FormField control={form.control} name="name" render={({ field }) => (
                <FormItem>
                  <FormLabel>Product Name</FormLabel>
                  <FormControl><Input placeholder="e.g., Premium Rice" {...field} /></FormControl>
                  <FormMessage />
                </FormItem>
              )} />
              
              <FormField control={form.control} name="type" render={({ field }) => (
                <FormItem>
                  <FormLabel>Product Type</FormLabel>
                  <Select onValueChange={field.onChange} value={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select type" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="platform">Platform</SelectItem>
                      <SelectItem value="business">Business</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )} />
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
              <FormField control={form.control} name="categoryId" render={({ field }) => (
                <FormItem>
                  <FormLabel>Category</FormLabel>
                  {categories.length > 0 ? (
                    <Select onValueChange={field.onChange} value={field.value}>
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select category" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {categories.map(category => (
                          <SelectItem key={category.id} value={String(category.id)}>
                            {category.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    <FormControl>
                      <Input placeholder="Category ID" {...field} />
                    </FormControl>
                  )}
                  <FormMessage />
                </FormItem>
              )} />
              
              <FormField control={form.control} name="manufacturerId" render={({ field }) => (
                <FormItem>
                  <FormLabel>Manufacturer</FormLabel>
                  <Select onValueChange={field.onChange} value={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select manufacturer" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {manufacturers.map(manufacturer => (
                        <SelectItem key={manufacturer.id} value={String(manufacturer.id)}>
                          {manufacturer.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )} />
            </div>
            
            <div className="mt-4">
              <FormField control={form.control} name="description" render={({ field }) => (
                <FormItem>
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Product description..." 
                      className="min-h-[120px]" 
                      {...field} 
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )} />
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
              <FormField control={form.control} name="isActive" render={({ field }) => (
                <FormItem className="flex flex-row items-center justify-between rounded-lg border p-3">
                  <div className="space-y-0.5">
                    <FormLabel>Product Status</FormLabel>
                    <p className="text-sm text-muted-foreground">
                      Active products are visible to customers
                    </p>
                  </div>
                  <FormControl>
                    <Switch 
                      checked={field.value} 
                      onCheckedChange={field.onChange} 
                    />
                  </FormControl>
                </FormItem>
              )} />
              
              <FormField control={form.control} name="stockAlert" render={({ field }) => (
                <FormItem className="flex flex-row items-center justify-between rounded-lg border p-3">
                  <div className="space-y-0.5">
                    <FormLabel>Stock Alerts</FormLabel>
                    <p className="text-sm text-muted-foreground">
                      Enable low stock notifications
                    </p>
                  </div>
                  <FormControl>
                    <Switch 
                      checked={field.value} 
                      onCheckedChange={field.onChange} 
                    />
                  </FormControl>
                </FormItem>
              )} />
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
              <FormField control={form.control} name="criticalLevel" render={({ field }) => (
                <FormItem>
                  <FormLabel>Critical Stock Level</FormLabel>
                  <FormControl>
                    <Input type="number" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )} />
              
              <FormField control={form.control} name="targetLevel" render={({ field }) => (
                <FormItem>
                  <FormLabel>Target Stock Level</FormLabel>
                  <FormControl>
                    <Input type="number" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )} />
            </div>
          </div>

          {/* Product Options */}
          <div className="space-y-4">
            <div className="flex justify-between items-center">
              <h3 className="text-lg font-medium">Product Options</h3>
              <div className="flex gap-2">
                <Button 
                  type="button" 
                  variant="outline" 
                  size="sm"
                  onClick={handlePasteOption}
                  disabled={!copiedOption}
                >
                  Paste Option
                </Button>
                <Button 
                  type="button" 
                  variant="default" 
                  size="sm"
                  onClick={() => append({
                    value: "",
                    price: 0,
                    inventory: 0,
                    stockPrice: 0,
                    markupType: "PERCENTAGE",
                    markupValue: 0,
                    sellingPrice: 0,
                    weight: 0,
                    unit: "",
                    moq: 1,
                    lowStockThreshold: 10,
                    image: [],
                    newImages: []
                  })}
                >
                  Add Option
                </Button>
              </div>
            </div>

            {fields.map((field, index) => (
              <OptionFormFields 
                key={field.id} 
                form={form} 
                index={index} 
                onCopy={handleCopyOption}
                onRemove={remove}
                calculateSellingPrice={calculateSellingPrice}
              />
            ))}
          </div>

          {/* Form Actions */}
          <div className="flex justify-end gap-4 pt-6">
            <Button 
              type="button" 
              variant="outline" 
              onClick={setClose}
              disabled={isSubmitting || isUploading}
            >
              Cancel
            </Button>
            <Button 
              type="submit" 
              disabled={isSubmitting || isUploading}
            >
              {isSubmitting ? "Updating..." : "Update Product"}
            </Button>
          </div>
        </form>
      </Form>
    </div>
  );
};

// Option form fields component
interface OptionFormFieldsProps {
  form: any;
  index: number;
  onCopy: (index: number) => void;
  onRemove: (index: number) => void;
  calculateSellingPrice: (index: number) => void;
}

const OptionFormFields: React.FC<OptionFormFieldsProps> = ({ 
  form, 
  index, 
  onCopy, 
  onRemove, 
  calculateSellingPrice 
}) => {
  return (
    <div className="p-4 border rounded-lg space-y-4 relative bg-slate-50">
      <div className="absolute top-2 right-2 flex gap-2">
        <Button 
          type="button" 
          variant="outline" 
          size="icon" 
          className="h-7 w-7"
          onClick={() => onCopy(index)}
        >
          <Copy className="h-4 w-4" />
        </Button>
        <Button 
          type="button" 
          variant="destructive" 
          size="icon" 
          className="h-7 w-7"
          onClick={() => onRemove(index)}
        >
          <Trash className="h-4 w-4" />
        </Button>
      </div>
      
      <p className="font-semibold text-md">Option #{index + 1}</p>
      
      {/* Basic Option Details */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <FormField
          control={form.control}
          name={`options.${index}.value`}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Option Value</FormLabel>
              <FormControl>
                <Input placeholder="e.g., 50KG" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name={`options.${index}.unit`}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Unit</FormLabel>
              <FormControl>
                <Input placeholder="e.g., Bag" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name={`options.${index}.weight`}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Weight (kg)</FormLabel>
              <FormControl>
                <Input type="number" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name={`options.${index}.moq`}
          render={({ field }) => (
            <FormItem>
              <FormLabel>MOQ</FormLabel>
              <FormControl>
                <Input type="number" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>

      {/* Pricing Fields */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <FormField
          control={form.control}
          name={`options.${index}.stockPrice`}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Cost Price (₦)</FormLabel>
              <FormControl>
                <Input 
                  type="number" 
                  {...field} 
                  onChange={(e) => {
                    field.onChange(e);
                    calculateSellingPrice(index);
                  }}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name={`options.${index}.markupType`}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Markup Type</FormLabel>
              <Select 
                onValueChange={(value) => {
                  field.onChange(value);
                  calculateSellingPrice(index);
                }} 
                value={field.value}
              >
                <FormControl>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="PERCENTAGE">Percentage (%)</SelectItem>
                  <SelectItem value="FIXED">Fixed (₦)</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name={`options.${index}.markupValue`}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Markup Value</FormLabel>
              <FormControl>
                <Input 
                  type="number" 
                  {...field} 
                  onChange={(e) => {
                    field.onChange(e);
                    calculateSellingPrice(index);
                  }}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name={`options.${index}.sellingPrice`}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Selling Price (₦)</FormLabel>
              <FormControl>
                <Input 
                  type="number" 
                  {...field} 
                  readOnly
                  className="bg-gray-100"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>
      
      {/* Inventory and Stock */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <FormField
          control={form.control}
          name={`options.${index}.inventory`}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Current Inventory</FormLabel>
              <FormControl>
                <Input type="number" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name={`options.${index}.lowStockThreshold`}
          render={({ field }) => (
            <FormItem>
              <FormLabel>Low Stock Threshold</FormLabel>
              <FormControl>
                <Input type="number" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>

      {/* Image Upload Component */}
      <ImageUploader form={form} index={index} />
    </div>
  );
};

// Image uploader component
const ImageUploader = ({ form, index }: { form: any; index: number }) => {
  const existingImages = form.watch(`options.${index}.image`) || [];
  const newFiles = form.watch(`options.${index}.newImages`) || [];

  const onDrop = useCallback((acceptedFiles: File[]) => {
    const currentFiles = form.getValues(`options.${index}.newImages`) || [];
    form.setValue(`options.${index}.newImages`, [...currentFiles, ...acceptedFiles]);
  }, [form, index]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    accept: { 'image/*': ['.jpeg', '.png', '.jpg'] },
    onDrop,
  });
  
  const removeExistingImage = (imgUrl: string) => {
    const updatedImages = existingImages.filter((url: string) => url !== imgUrl);
    form.setValue(`options.${index}.image`, updatedImages);
  };

  const removeNewFile = (fileIndex: number) => {
    const updatedFiles = newFiles.filter((_: any, i: number) => i !== fileIndex);
    form.setValue(`options.${index}.newImages`, updatedFiles);
  };

  return (
    <div className="space-y-2">
      <FormLabel>Product Images</FormLabel>
      <div 
        {...getRootProps()} 
        className={`p-4 border-2 border-dashed rounded-lg text-center cursor-pointer transition-colors ${
          isDragActive ? 'border-primary bg-primary/10' : 'border-gray-300 hover:border-gray-400'
        }`}
      >
        <input {...getInputProps()} />
        <UploadCloud className="mx-auto h-10 w-10 text-gray-400" />
        <p className="mt-1 text-sm text-gray-600">
          Drag & drop or click to add images
        </p>
      </div>
      
      {(existingImages.length > 0 || newFiles.length > 0) && (
        <div className="flex gap-2 flex-wrap mt-2">
          {/* Existing images */}
          {existingImages.map((url: string, imgIndex: number) => (
            <div key={`existing-${imgIndex}`} className="relative h-20 w-20">
              <Image 
                src={url} 
                alt="Product image" 
                fill
                className="rounded-md object-cover" 
              />
              <button 
                type="button" 
                onClick={() => removeExistingImage(url)}
                className="absolute -top-1 -right-1 bg-red-600 text-white rounded-full p-1 h-5 w-5 flex items-center justify-center shadow-md"
              >
                <Trash className="h-3 w-3" />
              </button>
            </div>
          ))}
          
          {/* New file previews */}
          {newFiles.map((file: File, fileIndex: number) => (
            <div key={`new-${fileIndex}`} className="relative h-20 w-20">
              <Image 
                src={URL.createObjectURL(file)} 
                alt="Preview" 
                fill
                className="rounded-md object-cover" 
              />
              <button 
                type="button" 
                onClick={() => removeNewFile(fileIndex)}
                className="absolute -top-1 -right-1 bg-red-600 text-white rounded-full p-1 h-5 w-5 flex items-center justify-center shadow-md"
              >
                <Trash className="h-3 w-3" />
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default EditProductForm;